
;
;**************************************************************************************************
;	- Programa para comparar o comportamento da leitura de teclado de forma direta e usando a interrupção
;	- O programa verifica se tem tecla.
;		- Se tiver, colocar no visor;
;		- Se não tiver, entra em um wait de 10 segundos
;	- No laco principal tem duas funções:
;		1. DisplayTeclado: lê o teclado e coloca no visor
;		2. Wait: fornece a temporização de 10 segundos
;	- São duas versões do programa
;		1. Versão sem interrupção -> mostra-se que serão perdidas teclas, mesmo com um buffer no PP
;		2. Versão com interrupção -> mostra-se que as teclas podem ser armazenadas em um buffer, na ISR
;	- Versão 1
;		<<1>> Configuração da interrupção
;		<<2>> Configuração da leitura de teclado
;		
;
;**************************************************************************************************
;


;==========================================================================
; Área Reservada

; Acesso em 16 bits
		org		hff80
STACK:
		daw		[31]		; Área reservada
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		dab		[24]
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor


;==========================================================================
;
org		0
INI:
mov		#STACK,r6
clr		INTS			; Reset pedidos de interrupção
clr 	TECST			; Reset estado do hardware do teclado
mov		#isr,IVET		; Set Interrupt Service Rotine

jsr		r7,ClearDisplay

mov		#h82,INTE		; Habilita: TECLADO=0x82   TIMER=0x81
main:
		hlt
	main_loop:
		jsr		r7,DisplayTimers
		jsr		r7,Wait
		jmp		main_loop

DisplayTimers:
		rts 	r7

DisplaySecTimer:; r0 = totalSec, r1 = display_section[5]
		mov 	r0, r2

		rts		r7

csec2seccsec:
		MOV	4(R6),R0	; R0 = csec
		MOV 2(R6),R1	; R1 = &[sec,csec]

		; sec, csec = div csec 100
		MOV R0,-(R6)
		MOV #100,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

sec2minsec:
		MOV	4(R6),R0	; R0 = sec
		MOV 2(R6),R1	; R1 = &[min,sec]

		; min, sec = div sec 60 
		MOV R0,-(R6)
		MOV #60,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

div:
		MOV	6(R6),R0	; R0 = a
		MOV	4(R6),R1	; R1 = b
		MOV	2(R6),R2	; R2 = &[quociente,resto]
		MOV	0,(R2)		; quociente = 0;

	div_loop:
		CMP	R0,R1		; while (a >= b) {
		BLT	div_end
		INC	(R3)		; 	++quociente;
		SUB	R1,R0		; 	a -= b;
		JMP	div_loop	; }

	div_end:
		MOV R0,2(R2)	; resto = a
		RTS	R7			; return;

Tab10:		DAW	10000, 1000, 100, 10
uint2str:
		MOV	2(R6),R1	; R1 = s
		MOV	4(R6),R2	; R2 = n

		MOV	#Tab10,R4	; pTab10 = Tab10;
		MOV	#4,R5		; Lacos = 4;
		
	uint2str_Loop:				; do {
		MOV	#'0',R3		; 	dig = '0';

	uint2str_LoopInterno:
		CMP	R2,(R4)		; 	while (n >= *pTab10) {
		BLT	uint2str_EhMenor
		INC	R3			; 		++dig;
		SUB	(R4),R2		; 		n -= *pTab10;
		JMP	uint2str_LoopInterno ; 	}

	uint2str_EhMenor:
		MOV	-1(R1),R0	; 	*s++ = dig;
		AND	#HFF00,R0
		OR	R3,R0
		MOV	R0,-1(R1)
		INC	R1
		
		ADD	#2,R4		; 	++pTab10;

		SOB	R5,uint2str_Loop ; } while (--Lacos);
		
		ADD	#'0',R2		; *s++ = n + '0';
		MOV	-1(R1),R0
		AND	#HFF00,R0
		OR	R2,R0
		MOV	R0,-1(R1)
		INC	R1
		
		MOV	-1(R1),R0	; *s++ = '\0';
		AND	#HFF00,R0
		MOV	R0,-1(R1)
		
		RTS	R7


;
;**************************************************************************************************
; Simula um processamento demorado
Wait:
		mov		#10,r0
WaitLoopR0:
		mov		#30000,r1
WaitLoopR1:
		sob		r1,WaitLoopR1
		sob		r0,WaitLoopR0
		rts		r7
		
;
;**************************************************************************************************
; Limpa o visor
base_visor:		dab '000,00[0] 000,00[0] 000,00[0]  00:00'
ClearDisplay:
		MOV #36,-(R6)

		MOV #base_visor,-(R6)
		DEC (R6)	;MOV para algum endereco do visor ignora o MSB, entao comecamos antes

		MOV #VISOR,-(R6)
		JSR R7,memcpy
		ADD #6,R6
		RTS R7
		
memcpy:
		MOV	6(R6),R0	; R0 = len
		MOV 4(R6),R1	; R1 = &src_start
		MOV 2(R6),R2	; R2 = &src_dest

	memcpy_loop:
		TST R0
		BEQ memcpy_end	; while R0 != 0
		MOV (R1),(R2)
		INC R1
		INC R2
		DEC R0
		JMP memcpy_loop
	memcpy_end:
		RTS	R7
;
;**************************************************************************************************
; Rotinas para a manipulação do hardware e interrupção (se houver) do teclado
; TeclaDisponivel	-> Rotina que informa se algo foi digitado
; GetTecla			-> Rotina que retorna a tecla digitada

; <<2>> Configuração da leitura de teclado

;
; Rotina que informa se algo foi digitado
; Retorna R0==0, se nada digitado; R0!=0, se algo digitado
TeclaDisponivel:	jmp		TeclaDisponivel_2

; Rotina que retorna a tecla digitada
GetTecla:			jmp		GetTecla_2


; Versão 2 das funções
TeclaDisponivel_2:
		and		#h7f,INTE			; IE = 0;
		
		clr		r0					; R0 = (prOut==ptIn ? FALSE:TRUE);
		cmp		ptOut, ptIn
		beq		TD_2_1
		mov		#1,r0
TD_2_1:

		or		#h80,INTE			; IE = 1;
		rts		r7
		
GetTecla_2:
		and		#h7f,INTE			; IE = 0
		
		mov		ptOut,r1			; r0 = *ptOut++
		dec		r1
		mov		TEC_BUFFER(r1),r0
		add		#2,r1
		
		and		#hff,r0				; r0 &= 0xFF
		
		and		#h1f,r1				; ptOut = ptOut & 0x1F // loop around pointer
		mov		r1,ptOut		
		
		or		#h80,INTE			; IE = 1
		rts		r7

				
;
;**************************************************************************************************
; Rotina de INTERRUPÇÃO
; Só será chamada se as interrupções estiverem habilitadas
isr:
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)
isr1:
		mov		INTS,r0		; Verifica se é INT do TIMER
		and		#1,r0
		beq		isr2
		jsr		r7,isr_tim	; Tratamento da INT do TIMER
		and		#hFFFE,INTS	; Desliga bit de INT TIMER
isr2:
		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		isr3
		jsr		r7,isr_tec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO
isr3:

		mov		(r6)+,r5	; Retorna os registradores da pilha
		mov		(r6)+,r4
		mov		(r6)+,r3
		mov		(r6)+,r2
		mov		(r6)+,r1
		mov		(r6)+,r0

		rti					; Return From Interrupt


; Tratamento das interrupções de teclado
isr_tec:
		tst		TECST				; if (Tecla está disponivel?) {
		beq		isr_tec_end
		
		mov		ptIn,r2				; 		p = (in+1)&0x1F
		inc		r2
		and		#h1F,r2
		cmp		r2,ptOut			; 		if (p!=out) { // Verifica se o BUFFER ESTA CHEIO
		beq		isr_tec_2
		
		mov		ptIn,r1				;				*in = TECLA
		dec		r1
		mov		TEC_BUFFER(r1),r0
		and		#hFF00,r0
		or		TECDT,r0
		mov		r0,TEC_BUFFER(r1)
		
		mov		r2,ptIn				;				in = p
									; 		}

isr_tec_2:
		clr 	TECST				;
	
isr_tec_end:	
		rts	r7						; }
	

isr_tim:
		inc		TICKCNT
		mov		#1,TICK
isr_tim_end:
		rts		r7
		
; VAR
TICKCNT:			dw	0
TICK:				dw	0

sec_since_start: 	dw	0
cs_since_tec: 		daw [3]
laps:				daw	[3]


min:				dw 0
sec:				dw 0
sec_csec:			daw [6]

ptIn:				dw	0
ptOut:				dw	0
TEC_BUFFER:			dab	[32]
