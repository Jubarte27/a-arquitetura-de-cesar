
;
;**************************************************************************************************
;	- Programa para comparar o comportamento da leitura de teclado de forma direta e usando a interrupção
;	- O programa verifica se tem tecla.
;		- Se tiver, colocar no visor;
;		- Se não tiver, entra em um wait de 10 segundos
;	- No laco principal tem duas funções:
;		1. DisplayTeclado: lê o teclado e coloca no visor
;		2. Wait: fornece a temporização de 10 segundos
;	- São duas versões do programa
;		1. Versão sem interrupção -> mostra-se que serão perdidas teclas, mesmo com um buffer no PP
;		2. Versão com interrupção -> mostra-se que as teclas podem ser armazenadas em um buffer, na ISR
;	- Versão 1
;		<<1>> Configuração da interrupção
;		<<2>> Configuração da leitura de teclado
;		
;
;**************************************************************************************************
;


;==========================================================================
; Área Reservada

; Acesso em 16 bits
		org		hff80
STACK:
		daw		[31]		; Área reservada
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		dab		[23]
TIMDT:	db		0
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor


;==========================================================================
;
org		0
INI:
mov		#STACK,R6
clr		INTS			; Reset pedidos de interrupção
clr 	TECST			; Reset estado do hardware do teclado

JSR		R7,ClearDisplay

mov		#ISR,IVET		; Set Interrupt Service Rotine
mov		#H83,INTE		; Habilita: TECLADO=0x82   TIMER=0x81
mov		#10,TIMDT		; 10ms = 1cs
mov 	#100,TICKS_TIL_SEC

main:
	main_loop:
		JSR R7,AnswerKeys
		JSR R7,CallFrozen5Seconds
		JSR	R7,DisplayTimers
		; JSR r7,Wait
		JMP	main_loop
		HLT

CallFrozen5Seconds:
		MOV #0,R0
		JSR R7,Frozen5Seconds
		MOV #1,R0
		JSR R7,Frozen5Seconds
		MOV #2,R0
		JSR R7,Frozen5Seconds
		RTS R7

;Verifica se o cronômetro está em S_FROZEN por 5 ou mais segundos e toma as providências necessárias
Frozen5Seconds:; recebe index em R0
		ASL R0

		MOV #states,R2				; R2 = &states[R0]
		ADD R0,R2

		CMP (R2),S_FROZEN
		BNE Frozen5Seconds_end		; Não está Frozen, não mexo

		MOV R0,R1
		ASL R1
		ADD #time_since_tec,R1		; R3 = &time_since_tec[R0] ; (time_since_tec contem pares)
		
		CMP (R1),#5
		BLT Frozen5Seconds_end		; Não está há 5 segundos ou mais em Frozen, não mexo
		
		MOV S_SHOW, (R2)			; Estou em frozen a 5 segundos ou mais, vou para Show

	Frozen5Seconds_end:
		RTS R7

AnswerKeys:
		JSR R7,TeclaDisponivel	; if TeclaDisponivel? 
		TST R0
		BEQ AnswerKeys_end

		JSR R7,GetTecla			; R0 = GetTecla

		SUB #'1',R0				; if GetTecla < '1' then goto AnswerKeys_not123
		BLT AnswerKeys_not123
								; else
		CMP R0,#3				; if GetTecla > '3' then goto AnswerKeys_not123
		BGE AnswerKeys_not123
								; else
		JSR R7,ToNextState		; ToNextState R0

	AnswerKeys_not123:
		JMP AnswerKeys			; próxima tecla
	AnswerKeys_end:
		RTS R7

ToNextState:; Recebe o indice do contador em R0
		ASL R0					; R0 = index * 2; Facilita acesso em memória
		MOV #states,R1
		ADD R0,R1				; R1 = &states[R0]

		MOV #laps,R2
		ADD R0,R2				; R2 = &laps[R0]

	ToNextState_FromWait:
		CMP (R1),S_WAIT			; if states[R0] == S_WAIT then
		BNE ToNextState_FromWait_end
		MOV S_SHOW,(R1)			; states[R0] = S_SHOW

		MOV #1,(R2)				; laps[R0] = 1

		JMP ToNextState_end
	ToNextState_FromWait_end:

		; Show e Frozen zeram o cronomêtro
		MOV R0,R3
		ASL R3
		ADD #time_since_tec,R3	; R3 = &time_since_tec[R0] ; (time_since_tec contem pares)
		CLR (R3)
		CLR 2(R3)				; time_since_tec[R0] = (0,0) ; Zerar cronômetro
		
	ToNextState_FromShow:
		CMP (R1),S_SHOW			; if states[R0] == S_SHOW then
		BNE ToNextState_FromShow_end
		MOV S_FROZEN,(R1)		; states[R0] = S_FROZEN

		INC (R2)									; lap[R0] = (lap[R0] + 1) % 10
		ToNextState_FromShow_lapmod10:				;
			CMP (R2),#10							;
			BLT ToNextState_FromShow_lapmod10_end	;
			SUB #10,(R2)							;
			JMP ToNextState_FromShow_lapmod10		;
		ToNextState_FromShow_lapmod10_end:			;

		JMP ToNextState_end
	ToNextState_FromShow_end:

	ToNextState_FromFrozen:
		CMP (R1),S_FROZEN			; if states[R0] == S_FROZEN then
		BNE ToNextState_FromFrozen_end; Ninguem sabe o que esta em states[R0]
		MOV S_WAIT,(R1)		; states[R0] = S_WAIT; Se cheguei aqui, não pode ter passado de 5 segundos em Frozen, logo mudo para S_WAIT

		CLR (R2)				; laps[R0] = 0 ; zerar laps

		ASR R0
		MOV R0,-(R6)
		JSR R7 DisplayCSecTimer	; Update no visor 1 vez para zerar
		ADD #2,R6
		
		JMP ToNextState_end
	ToNextState_FromFrozen_end:

	ToNextState_end:
		RTS R7


DisplayTimers:
		JSR R7, DisplaySecTimer

		MOV #0, -(R6)
		JSR R7,IfNeedDisplayCSecTimer
		ADD #2, R6

		MOV #1, -(R6)
		JSR R7,IfNeedDisplayCSecTimer
		ADD #2, R6

		MOV #2, -(R6)
		JSR R7,IfNeedDisplayCSecTimer
		ADD #2 R6

		RTS r7

IfNeedDisplayCSecTimer:

		MOV 2(R6),R0	; R0 = timer_index (starts at 0)

		MOV R0,R1
		ASL R1			; R1 = 2 * timer_index

		MOV #states,R2
		ADD R1,R2		; R2 = &states[timer_index]
		MOV (R2),R2
		AND C_UPDATE_VISOR,R2
		BEQ IfNeedDisplayCSecTimer_end	; Se é um estado que não atualiza o visor, pula rotina de escrita

		MOV R0,-(R6)
		JSR R7 DisplayCSecTimer	; Update no visor 1 vez para zerar
		ADD #2, R6

IfNeedDisplayCSecTimer_end:
		RTS R7


; 65500 + 0, 65500 + 10, 65500 + 20
TIMER_SEC_POSITION: daw 65500,65510,65520
DisplayCSecTimer:
		MOV 2(R6),R0	; R0 = timer_index (starts at 0)

		MOV R0,R1
		ASL R1			; R1 = 2 * timer_index
		MOV #TIMER_SEC_POSITION,R4 ; R4 = TIMER_SEC_POSITION[timer_index]
		ADD R1,R4
		MOV (R4),R4

		MOV #laps,R5
		ADD R1,R5		; R5 = &laps[timer_index]
		
		ASL R1			; R1 = 4 * timer_index
		MOV #time_since_tec,R3 ; R3 = time_since_tec + timer_index
		ADD R1,R3

	MOV R3,-(R6)
	MOV R4,-(R6)
	MOV R5,-(R6)
		MOV (R3),-(R6)
		MOV R4,-(R6)
		MOV #3,-(R6)
		JSR R7, uint2str
		ADD #6,R6
	MOV (R6)+,R5
	MOV (R6)+,R4
	MOV (R6)+,R3

		ADD #4,R4		; 4 characteres entre início dos segundos e início dos centésimos

	MOV R4,-(R6)
	MOV R5,-(R6)
		MOV 2(R3),-(R6)
		MOV R4,-(R6)
		MOV #2,-(R6)
		JSR R7, uint2str
		ADD #6,R6
	MOV (R6)+,R4
	MOV (R6)+,R4


		ADD #3,R4		; 3 characteres entre início dos centésimos e as LAPS

		MOV (R5),-(R6)
		MOV R4,-(R6)
		MOV #1,-(R6)
		JSR R7, uint2str
		ADD #6,R6

		RTS R7

DisplaySecTimer:

		MOV min_since_start,-(R6)
		MOV #65531,-(R6); Posição dos minutos no visor
		MOV #2,-(R6)	; 2 espaços para minutos no visor
		JSR R7, uint2str
		ADD #6,R6

		MOV sec_since_start,-(R6)
		MOV #65534,-(R6); Posição dos segundos no visor
		MOV #2,-(R6)	; 2 espaços para segundos no visor
		JSR R7, uint2str
		ADD #6,R6

		rts		r7

csec2seccsec:
		MOV	4(R6),R0	; R0 = csec
		MOV 2(R6),R1	; R1 = &[sec,csec]

		; sec, csec = div csec 100
		MOV R0,-(R6)
		MOV #100,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

sec2minsec:
		MOV	4(R6),R0	; R0 = sec
		MOV 2(R6),R1	; R1 = &[min,sec]

		; min, sec = div sec 60 
		MOV R0,-(R6)
		MOV #60,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

div:
		MOV	6(R6),R0	; R0 = a
		MOV	4(R6),R1	; R1 = b
		MOV	2(R6),R2	; R2 = &[quociente,resto]
		MOV	#0,(R2)		; quociente = 0;

	div_loop:
		CMP	R0,R1		; while (a >= b) {
		BLT	div_end
		INC	(R2)		; 	++quociente;
		SUB	R1,R0		; 	a -= b;
		JMP	div_loop	; }

	div_end:
		MOV R0,2(R2)	; resto = a
		RTS	R7			; return;

uint2str_aux: daw [2]
uint2str:; uses R0, R1, R2, R3, R4
		MOV	6(R6),R0	; R0 = src -> uint
		MOV	4(R6),R1	; R1 = *dst -> byte array
		MOV	2(R6),R2	; R2 = dst_len -> uint

		MOV #uint2str_aux,R3

		; R4 = *end
		MOV R2, R4
		DEC R4
		ADD R1, R4
		
	uint2str_loop:
		CMP R4,R1
		BLT uint2str_end

		; uint2str_aux = div src 10
		MOV R1,-(R6)
		MOV R2,-(R6)
		MOV R3,-(R6)
		MOV R4,-(R6)

		MOV R0,-(R6)
		MOV #10,-(R6)
		MOV R3,-(R6)
		JSR R7,div
		ADD #6,R6

		MOV (R6)+,R4
		MOV (R6)+,R3
		MOV (R6)+,R2
		MOV (R6)+,R1

		; R0 = quociente
		MOV (R3), R0

		; R1 = resto + '0'
		AND #H00FF,2(R3)
		ADD #'0',2(R3)
		MOV 2(R3),(R4)

		DEC R4
		JMP uint2str_loop
		
	uint2str_end:
		RTS	R7


;
;**************************************************************************************************
; Simula um processamento demorado
Wait:
		mov		#10,r0
	WaitLoopR0:
		mov		#30000,r1
	WaitLoopR1:
		sob		r1,WaitLoopR1
		sob		r0,WaitLoopR0
		rts		r7
		
;
;**************************************************************************************************
; Limpa o visor
base_visor:		dab '000,00[0] 000,00[0] 000,00[0]  00:00'
ClearDisplay:
		MOV #36,-(R6)

		MOV #base_visor,-(R6)
		DEC (R6)	;MOV para algum endereco do visor ignora o MSB, entao comecamos antes

		MOV #VISOR,-(R6)
		JSR R7,memcpy
		ADD #6,R6
		RTS R7
		
memcpy:
		MOV	6(R6),R0	; R0 = len
		MOV 4(R6),R1	; R1 = &src_start
		MOV 2(R6),R2	; R2 = &src_dest

	memcpy_loop:
		TST R0
		BEQ memcpy_end	; while R0 != 0
		MOV (R1),(R2)
		INC R1
		INC R2
		DEC R0
		JMP memcpy_loop
	memcpy_end:
		RTS	R7
;
;**************************************************************************************************
; Rotinas para a manipulação do hardware e interrupção (se houver) do teclado
; TeclaDisponivel	-> Rotina que informa se algo foi digitado
; GetTecla			-> Rotina que retorna a tecla digitada

; Rotina que informa se algo foi digitado
; Retorna R0==0, se nada digitado; R0!=0, se algo digitado
TeclaDisponivel:
		and		#h7f,INTE			; IE = 0;
		
		clr		r0					; R0 = (prOut==ptIn ? FALSE:TRUE);
		cmp		ptOut, ptIn
		beq		TeclaDisponivel_1
		mov		#1,r0
	TeclaDisponivel_1:
		or		#h80,INTE			; IE = 1;
		rts		r7
		
GetTecla:
		and		#h7f,INTE			; IE = 0
		
		mov		ptOut,r1			; r0 = *ptOut++
		dec		r1
		mov		TEC_BUFFER(r1),r0
		add		#2,r1
		
		and		#hff,r0				; r0 &= 0xFF
		
		and		#h1f,r1				; ptOut = ptOut & 0x1F // loop around pointer
		mov		r1,ptOut		
		
		or		#h80,INTE			; IE = 1
		rts		r7

				
;
;**************************************************************************************************
; Rotina de INTERRUPÇÃO
; Só será chamada se as interrupções estiverem habilitadas
ISR:
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)
	isr1:
		mov		INTS,r0		; Verifica se é INT do TIMER
		and		#1,r0
		beq		isr2
		JSR		r7,isr_tim	; Tratamento da INT do TIMER
		and		#hFFFE,INTS	; Desliga bit de INT TIMER
	isr2:
		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		isr3
		JSR		r7,isr_tec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO
	isr3:

		mov		(r6)+,r5	; Retorna os registradores da pilha
		mov		(r6)+,r4
		mov		(r6)+,r3
		mov		(r6)+,r2
		mov		(r6)+,r1
		mov		(r6)+,r0

		rti					; Return From Interrupt


; Tratamento das interrupções de teclado
isr_tec:
		tst		TECST				; if (Tecla está disponivel?) {
		beq		isr_tec_end
		
		mov		ptIn,r2				; 		p = (in+1)&0x1F
		inc		r2
		and		#h1F,r2
		cmp		r2,ptOut			; 		if (p!=out) { // Verifica se o BUFFER ESTA CHEIO
		beq		isr_tec_2
		
		mov		ptIn,r1				;				*in = TECLA
		dec		r1
		mov		TEC_BUFFER(r1),r0
		and		#hFF00,r0
		or		TECDT,r0
		mov		r0,TEC_BUFFER(r1)
		
		mov		r2,ptIn				;				in = p
									; 		}

	isr_tec_2:
		clr 	TECST				;
	
	isr_tec_end:	
		rts	r7						; }
	

isr_tim:
	ISR_TIM_TOTAL:
		DEC TICKS_TIL_SEC
		BGT ISR_TIM_TOTAL_END

		INC sec_since_start
		MOV #100, TICKS_TIL_SEC	; Deveria ser 1000 / TIMDT
		
		CMP sec_since_start, #60
		BLT ISR_TIM_TOTAL_END
		INC min_since_start
		CLR	sec_since_start
	ISR_TIM_TOTAL_END:
	ISR_TIM_UPDATE_COUNTER:
		MOV #0,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6
		
		MOV #1,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6
		
		MOV #2,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6

	isr_tim_end:
		RTS	r7

ISR_UPDATE_COUNTER:
		MOV 2(R6),R0
		ASL R0		; R0 = index * 2
		
		MOV #states,R2
		ADD R0,R2
		MOV (R2),R2

		AND C_UPDATE_COUNTER,R2
		BEQ ISR_UPDATE_COUNTER_END

		MOV R0,R1
		ASL R1		; R1 = index * 4

		MOV #time_since_tec,R2
		ADD R1,R2

		INC 2(R2)
		CMP 2(R2),#100
		BLT ISR_UPDATE_COUNTER_END

		CLR 2(R2)
		INC (R2)


	ISR_UPDATE_COUNTER_END:
		RTS R7

; VAR
TICKS_TIL_SEC:		dw	0
min_since_start:	dw  49	; Minutos completos desde o início do programa
sec_since_start: 	dw	34	; Segundos deste o último minuto completo (sec % 60)

time_since_tec: 	daw [6] ; Par (segundo,centesimos), 1 para cada cronômetro
laps:				daw	[3]	; Quantidade de voltas, 1 para cada cronomêtro
states:				daw [3] ; Estado dos contadores: S_WAIT (inicial), S_SHOW, S_FROZEN
							; 
; Máscaras para obter informações sobre os estados:
C_UPDATE_COUNTER:	dw 1	; 0000000000000001
C_UPDATE_VISOR:		dw 2	; 0000000000000010

; Estados
; Regra de criação:
;		byte menos significativo é o resultado da combinação das máscaras de informações sobre os estados
; 		byte mais significativo é o índice do estado: 0,1,2
S_WAIT:				dw H0000; 00000000 00000000
S_SHOW:				dw H0103; 00000001 00000011
S_FROZEN:			dw H0201; 00000010 00000001

ptIn:				dw	0
ptOut:				dw	0
TEC_BUFFER:			dab	[32]
