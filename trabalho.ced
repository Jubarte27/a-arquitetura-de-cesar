;==========================================================================
; Área Reservada
; Acesso em 16 bits
ORG		HFF80
STACK:
		daw		[31]		; Área reservada
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		dab		[23]
TIMDT:	db		0
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor


;==========================================================================
; Main

ORG		0
INI:
MOV		#STACK,R6
CLR		INTS			; Reset pedidos de interrupção
CLR 	TECST			; Reset estado do hardware do teclado

JSR		R7,RESET_VARS
JSR		R7,ClearDisplay

MOV		#10,TIMDT		; 10ms = 1cs
MOV		#ISR,IVET		; Set Interrupt Service Rotine
MOV		#H83,INTE		; Habilita: TECLADO=0x82   TIMER=0x81

MAIN:
	MAIN_LOOP:
		JSR R7,AnswerKeys
		JSR R7,CallFrozen5Seconds
		JSR	R7,DisplayTimers
		JMP	MAIN_LOOP
		HLT

;==========================================================================
; Funções

;--------------------------------------------------------------------------
; Lidar com o requisito de mudar o status de frozen para show
CallFrozen5Seconds:; recebe nada
		MOV #0,R0
		JSR R7,Frozen5Seconds
		MOV #1,R0
		JSR R7,Frozen5Seconds
		MOV #2,R0
		JSR R7,Frozen5Seconds
		RTS R7

; Verifica se o cronômetro está em S_FROZEN por 5 ou mais segundos e toma as providências necessárias
Frozen5Seconds:; recebe index em R0
		ASL R0

		MOV #states,R2				; R2 = &states[R0]
		ADD R0,R2

		CMP (R2),S_FROZEN
		BNE Frozen5Seconds_end		; Não está Frozen, não mexo

		MOV R0,R1
		ASL R1
		ADD #time_since_tec,R1		; R3 = &time_since_tec[R0] ; (time_since_tec contem pares)
		
		CMP (R1),#5
		BLT Frozen5Seconds_end		; Não está há 5 segundos ou mais em Frozen, não mexo
		
		MOV S_SHOW, (R2)			; Estou em frozen a 5 segundos ou mais, vou para Show

	Frozen5Seconds_end:
		RTS R7

;--------------------------------------------------------------------------
; Reponder aos comandos do teclado (teclas 1, 2 e 3)
AnswerKeys:; recebe nada
		JSR R7,TeclaDisponivel	; if TeclaDisponivel? 
		TST R0
		BEQ AnswerKeys_end

		JSR R7,GetTecla			; R0 = GetTecla

		SUB #'1',R0				; if GetTecla < '1' then goto AnswerKeys_not123
		BLT AnswerKeys_not123
								; else
		CMP R0,#3				; if GetTecla > '3' then goto AnswerKeys_not123
		BGE AnswerKeys_not123
								; else
		JSR R7,ToNextState		; ToNextState R0

	AnswerKeys_not123:
		JMP AnswerKeys			; próxima tecla
	AnswerKeys_end:
		RTS R7

;--------------------------------------------------------------------------
; Muda o estado do contador indicado em R0
ToNextState:; Recebe o indice do contador em R0
		ASL R0					; R0 = index * 2; Facilita acesso em memória
		MOV #states,R1
		ADD R0,R1				; R1 = &states[R0]

		MOV #laps,R2
		ADD R0,R2				; R2 = &laps[R0]

	ToNextState_FromWait:
		CMP (R1),S_WAIT			; if states[R0] == S_WAIT then
		BNE ToNextState_FromWait_end
		MOV S_SHOW,(R1)			; states[R0] = S_SHOW

		MOV #1,(R2)				; laps[R0] = 1

		JMP ToNextState_end
	ToNextState_FromWait_end:

		; Show e Frozen zeram o cronomêtro
		MOV R0,R3
		ASL R3
		ADD #time_since_tec,R3	; R3 = &time_since_tec[R0] ; (time_since_tec contem pares)
		CLR (R3)
		CLR 2(R3)				; time_since_tec[R0] = (0,0) ; Zerar cronômetro
		
	ToNextState_FromShow:
		CMP (R1),S_SHOW			; if states[R0] == S_SHOW then
		BNE ToNextState_FromShow_end
		MOV S_FROZEN,(R1)		; states[R0] = S_FROZEN

		INC (R2)									; lap[R0] = (lap[R0] + 1) % 10
		ToNextState_FromShow_lapmod10:				;
			CMP (R2),#10							;
			BLT ToNextState_FromShow_lapmod10_end	;
			SUB #10,(R2)							;
			JMP ToNextState_FromShow_lapmod10		;
		ToNextState_FromShow_lapmod10_end:			;

		JMP ToNextState_end
	ToNextState_FromShow_end:

	ToNextState_FromFrozen:
		CMP (R1),S_FROZEN			; if states[R0] == S_FROZEN then
		BNE ToNextState_FromFrozen_end; Ninguem sabe o que esta em states[R0]
		MOV S_WAIT,(R1)		; states[R0] = S_WAIT; Se cheguei aqui, não pode ter passado de 5 segundos em Frozen, logo mudo para S_WAIT

		CLR (R2)				; laps[R0] = 0 ; zerar laps

		ASR R0
		MOV R0,-(R6)
		JSR R7 DisplayCSecTimer	; Update no visor 1 vez para zerar
		ADD #2,R6
		
		JMP ToNextState_end
	ToNextState_FromFrozen_end:

	ToNextState_end:
		RTS R7

;--------------------------------------------------------------------------
; Atualiza os timers na tela se estiverem configurados para isso
DisplayTimers:
		JSR R7,DisplaySecTimer

		MOV #0,R0
		JSR R7,IfNeedDisplayCSecTimer

		MOV #1,R0
		JSR R7,IfNeedDisplayCSecTimer

		MOV #2,R0
		JSR R7,IfNeedDisplayCSecTimer

		RTS R7

IfNeedDisplayCSecTimer:; recebe o indice do timer em R0
		MOV R0,R1
		ASL R1			; R1 = 2 * timer_index

		MOV #states,R2
		ADD R1,R2		; R2 = &states[timer_index]
		MOV (R2),R2
		AND C_UPDATE_VISOR,R2
		BEQ IfNeedDisplayCSecTimer_end	; Se é um estado que não atualiza o visor, pula rotina de escrita

		JSR R7 DisplayCSecTimer	; Update no visor 1 vez para zerar
IfNeedDisplayCSecTimer_end:
		RTS R7

;--------------------------------------------------------------------------
; Atualiza 1 cronômetro no visor, independente do estado do cronomêtro
DisplayCSecTimer:; recebe o indice do timer em R0
		ASL R0			; R0 = 2 * timer_index

	MOV R0,-(R6)
		MOV laps(R0),-(R6)
		MOV TIMER_LAP_POSITION(R0),-(R6)
		MOV #1,-(R6)
		JSR R7, uint2str
		ADD #6,R6
	MOV (R6)+,R0
		
		MOV R0,R1
		ASL R1			; R1 = 4 * timer_index
		ADD #time_since_tec,R1 ; R1 = time_since_tec + timer_index

	MOV R1,-(R6)
	MOV R0,-(R6)
		MOV (R1),-(R6)
		MOV TIMER_SEC_POSITION(R0),-(R6)
		MOV #3,-(R6)
		JSR R7, uint2str
		ADD #6,R6
	MOV (R6)+,R0
	MOV (R6)+,R1

		MOV 2(R1),-(R6)
		MOV TIMER_CSEC_POSITION(R0),-(R6)
		MOV #2,-(R6)
		JSR R7, uint2str
		ADD #6,R6

		RTS R7
;--------------------------------------------------------------------------
; Atualiza o relógio que conta desde o início do programa
DisplaySecTimer:; recebe nada
		MOV min_since_start,-(R6)
		MOV #65531,-(R6); Posição dos minutos no visor
		MOV #2,-(R6)	; 2 espaços para minutos no visor
		JSR R7, uint2str
		ADD #6,R6

		MOV sec_since_start,-(R6)
		MOV #65534,-(R6); Posição dos segundos no visor
		MOV #2,-(R6)	; 2 espaços para segundos no visor
		JSR R7, uint2str
		ADD #6,R6

		RTS		R7

;--------------------------------------------------------------------------
; Divide a por b. Coloca o resultado no endereço apontado pelo 3º parâmetro 
DIV:; Recebe na pilha
		MOV	6(R6),R0	; R0 = a
		MOV	4(R6),R1	; R1 = b
		MOV	2(R6),R2	; R2 = &[quociente,resto]
		MOV	#0,(R2)		; quociente = 0;

	div_loop:
		CMP	R0,R1		; while (a >= b) {
		BLT	div_end
		INC	(R2)		; 	++quociente;
		SUB	R1,R0		; 	a -= b;
		JMP	div_loop	; }

	div_end:
		MOV R0,2(R2)	; resto = a
		RTS	R7			; return;

;--------------------------------------------------------------------------
; Transforma um inteiro sem sinal na sua representação em decimal com até n dígitos
uint2str:; recebe na pilha
		MOV	6(R6),R0	; R0 = src -> uint
		MOV	4(R6),R1	; R1 = *dst -> byte array
		MOV	2(R6),R2	; R2 = dst_len -> uint

		SUB #4,R6
		MOv R6,R3		; aloca 2 endereços na pilha para o resultado das divisões

		; R4 = *end
		MOV R2, R4
		DEC R4
		ADD R1, R4
		
	uint2str_loop:
		CMP R4,R1
		BLT uint2str_end

		; uint2str_aux = DIV src 10
	MOV R1,-(R6)
	MOV R2,-(R6)
	MOV R3,-(R6)
	MOV R4,-(R6)
		MOV R0,-(R6)
		MOV #10,-(R6)
		MOV R3,-(R6)
		JSR R7,DIV
		ADD #6,R6
	MOV (R6)+,R4
	MOV (R6)+,R3
	MOV (R6)+,R2
	MOV (R6)+,R1

		; R0 = quociente
		MOV (R3), R0

		; R1 = resto + '0'
		AND #H00FF,2(R3)
		ADD #'0',2(R3)
		MOV 2(R3),(R4)

		DEC R4
		JMP uint2str_loop
		
	uint2str_end:
		ADD #4,R6		; Free nos endereços alocados para resultado das divisões
		RTS	R7
		

;**************************************************************************************************
; Limpa o visor
ClearDisplay:
		MOV #36,-(R6)

		MOV #BASE_VISOR,-(R6)
		DEC (R6)	;MOV para algum endereco do visor ignora o MSB, entao comecamos antes

		MOV #VISOR,-(R6)
		JSR R7,memcpy
		ADD #6,R6
		RTS R7
		
memcpy:
		MOV	6(R6),R0	; R0 = len
		MOV 4(R6),R1	; R1 = &src_start
		MOV 2(R6),R2	; R2 = &src_dest

	memcpy_loop:
		TST R0
		BEQ memcpy_end	; while R0 != 0
		MOV (R1),(R2)
		INC R1
		INC R2
		DEC R0
		JMP memcpy_loop
	memcpy_end:
		RTS	R7
;
;**************************************************************************************************
; Rotinas para a manipulação do hardware e interrupção (se houver) do teclado
; TeclaDisponivel	-> Rotina que informa se algo foi digitado
; GetTecla			-> Rotina que retorna a tecla digitada

; Rotina que informa se algo foi digitado
; Retorna R0==0, se nada digitado; R0!=0, se algo digitado
TeclaDisponivel:
		AND		#H7F,INTE			; IE = 0;
		
		CLR		R0					; R0 = (prOut==ptIn ? FALSE:TRUE);
		CMP		ptOut, ptIn
		BEQ		TeclaDisponivel_1
		MOV		#1,R0
	TeclaDisponivel_1:
		OR		#H80,INTE			; IE = 1;
		RTS		R7
		
GetTecla:
		AND		#h7f,INTE			; IE = 0
		
		MOV		ptOut,R1			; R0 = *ptOut++
		DEC		R1
		MOV		TEC_BUFFER(R1),R0
		add		#2,R1
		
		AND		#HFF,R0				; R0 &= 0xFF
		
		AND		#H1F,R1				; ptOut = ptOut & 0x1F // loop around pointer
		MOV		R1,ptOut		
		
		OR		#H80,INTE			; IE = 1
		RTS		R7

				
;
;--------------------------------------------------------------------------
; Rotina de Interrupção
ISR:
		MOV		R0,-(R6)	; Salva registradores
		MOV		R1,-(R6)
		MOV		R2,-(R6)
		MOV		R3,-(R6)
		MOV		R4,-(R6)
		MOV		R5,-(R6)

	ISR1:
		MOV		INTS,R0		; Verifica se é INT do TIMER
		AND		#1,R0
		BEQ		ISR2
		JSR		R7,ISR_TIM	; Tratamento da INT do TIMER
		AND		#hFFFE,INTS	; Desliga bit de INT TIMER

	ISR2:
		MOV		INTS,R0		; Verifica se é INT do TECLADO
		AND		#2,R0
		BEQ		ISR_end
		JSR		R7,isr_tec	; Tratamento da INT do TECLADO
		AND		#hFFFD,INTS	; Desliga bit de INT TECLADO

	ISR_end:
		MOV		(R6)+,R5	; Retorna os registradores da pilha
		MOV		(R6)+,R4
		MOV		(R6)+,R3
		MOV		(R6)+,R2
		MOV		(R6)+,R1
		MOV		(R6)+,R0

		RTI					; Return From Interrupt

;--------------------------------------------------------------------------
; Tratamento das interrupções de teclado
isr_tec:
		TST		TECST				; if (Tecla está disponivel?) {
		BEQ		isr_tec_end
		
		MOV		ptIn,R2				; 		p = (in+1)&0x1F
		INC		R2
		AND		#h1F,R2
		CMP		R2,ptOut			; 		if (p!=out) { // Verifica se o BUFFER ESTA CHEIO
		BEQ		isr_tec_2
		
		MOV		ptIn,R1				;				*in = TECLA
		DEC		R1
		MOV		TEC_BUFFER(R1),R0
		AND		#hFF00,R0
		OR		TECDT,R0
		MOV		R0,TEC_BUFFER(R1)
		
		MOV		R2,ptIn				;				in = p
									; 		}

	isr_tec_2:
		CLR 	TECST				;
	
	isr_tec_end:	
		RTS	R7						; }
	
;--------------------------------------------------------------------------
;Tratamento das interrupções de timer
ISR_TIM:
	ISR_TIM_TOTAL:
		DEC TICKS_TIL_SEC
		BGT ISR_TIM_TOTAL_END

		INC sec_since_start
		MOV #100, TICKS_TIL_SEC	; Deveria ser 1000 / TIMDT
		
		CMP sec_since_start, #60
		BLT ISR_TIM_TOTAL_END
		INC min_since_start
		CLR	sec_since_start
	ISR_TIM_TOTAL_END:
	ISR_TIM_UPDATE_COUNTER:
		MOV #0,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6
		
		MOV #1,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6
		
		MOV #2,-(R6)
		JSR R7,ISR_UPDATE_COUNTER
		ADD #2,R6

	isr_tim_end:
		RTS	R7

ISR_UPDATE_COUNTER:
		MOV 2(R6),R0
		ASL R0		; R0 = index * 2
		
		MOV #states,R2
		ADD R0,R2
		MOV (R2),R2

		AND C_UPDATE_COUNTER,R2
		BEQ ISR_UPDATE_COUNTER_END

		MOV R0,R1
		ASL R1		; R1 = index * 4

		MOV #time_since_tec,R2
		ADD R1,R2

		INC 2(R2)
		CMP 2(R2),#100
		BLT ISR_UPDATE_COUNTER_END

		CLR 2(R2)
		INC (R2)

	ISR_UPDATE_COUNTER_END:
		RTS R7

;--------------------------------------------------------------------------
;Reseta valores das variáveis usadas pelo programa
RESET_VARS:
	CLR ptIn
	CLR ptOut
	MOV #100,TICKS_TIL_SEC
	CLR min_since_start
	CLR sec_since_start

	MOV #time_since_tec,R0
	MOV #6,R1
	JSR R7,RESET_VAR

	MOV #laps,R0
	MOV #3,R1
	JSR R7,RESET_VAR

	MOV #states,R0
	MOV #3,R1
	JSR R7,RESET_VAR

	RTS R7

RESET_VAR:;R0 = start, R1 = len (bytes/2); limpa de 2 em dois bytes
	CLR (R0)+
	DEC R1
	BGT RESET_VAR
	RTS R7
	

;==========================================================================
; Variáveis

ptIn:				dw	0
ptOut:				dw	0
TEC_BUFFER:			dab	[32]

TICKS_TIL_SEC:		dw	0
min_since_start:	dw  0	; Minutos completos desde o início do programa
sec_since_start: 	dw	0	; Segundos deste o último minuto completo (sec % 60)

time_since_tec: 	daw [6] ; Par (segundo,centesimos), 1 para cada cronômetro
laps:				daw	[3]	; Quantidade de voltas, 1 para cada cronomêtro
states:				daw [3] ; Estado dos contadores: S_WAIT (inicial), S_SHOW, S_FROZEN

;==========================================================================
; Constantes

;--------------------------------------------------------------------------
; Máscaras para obter informações sobre os estados:
C_UPDATE_COUNTER:	dw 1	; 0000000000000001
C_UPDATE_VISOR:		dw 2	; 0000000000000010

;--------------------------------------------------------------------------
; Estados
; Regra de criação:
;		byte menos significativo é o resultado da combinação das máscaras de informações sobre os estados
; 		byte mais significativo é o índice do estado: 0,1,2
S_WAIT:				dw H0000; 00000000 00000000
S_SHOW:				dw H0103; 00000001 00000011
S_FROZEN:			dw H0201; 00000010 00000001

;--------------------------------------------------------------------------
; Visor "vazio"
BASE_VISOR:			dab '000,00[0] 000,00[0] 000,00[0]  00:00'

;--------------------------------------------------------------------------
; Posição onde mostrar cada cronometro
; 65500 + 0, 65500 + 10, 65500 + 20
TIMER_SEC_POSITION:		daw 65500,65510,65520
; 65500 + 4, 65500 + 14, 65500 + 24
TIMER_CSEC_POSITION: 	daw 65504,65514,65524
; 65500 + 7, 65500 + 17, 65500 + 27
TIMER_LAP_POSITION: 	daw 65507,65517,65527
