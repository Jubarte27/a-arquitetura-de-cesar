
;
;**************************************************************************************************
;	- Programa para comparar o comportamento da leitura de teclado de forma direta e usando a interrupção
;	- O programa verifica se tem tecla.
;		- Se tiver, colocar no visor;
;		- Se não tiver, entra em um wait de 10 segundos
;	- No laco principal tem duas funções:
;		1. DisplayTeclado: lê o teclado e coloca no visor
;		2. Wait: fornece a temporização de 10 segundos
;	- São duas versões do programa
;		1. Versão sem interrupção -> mostra-se que serão perdidas teclas, mesmo com um buffer no PP
;		2. Versão com interrupção -> mostra-se que as teclas podem ser armazenadas em um buffer, na ISR
;	- Versão 1
;		<<1>> Configuração da interrupção
;		<<2>> Configuração da leitura de teclado
;		
;
;**************************************************************************************************
;


;==========================================================================
; Área Reservada

; Acesso em 16 bits
		org		hff80
STACK:
		daw		[31]		; Área reservada
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		dab		[23]
TIMDT:	db		0
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor


;==========================================================================
;
org		0
INI:
mov		#STACK,r6
clr		INTS			; Reset pedidos de interrupção
clr 	TECST			; Reset estado do hardware do teclado

jsr		r7,ClearDisplay

mov		#ISR,IVET		; Set Interrupt Service Rotine
mov		#H83,INTE		; Habilita: TECLADO=0x82   TIMER=0x81
mov		#10,TIMDT		; 10ms = 1cs
mov 	#100,TICKS_TIL_SEC

main:
	main_loop:
		jsr		r7,DisplayTimers
		jsr		r7,Wait
		jmp		main_loop
		hlt

DisplayTimers:
		JSR R7, DisplaySecTimer
		rts 	r7

; 65500 + 31
TOTAL_TIME_MIN_POSITION: dw 65531
; 65500 + 34
TOTAL_TIME_SEC_POSITION: dw 65534
; pattern = 00:00
DisplaySecTimer:
		; min, sec = sec2minsec sec_since_start &[min,sec]
		MOV sec_since_start, -(R6)
		MOV #min, -(R6)
		JSR R7, sec2minsec
		ADD #4, R6

		MOV min,-(R6)
		MOV TOTAL_TIME_MIN_POSITION,-(R6)
		MOV #2,-(R6)
		JSR R7, uint2str
		ADD #6,R6

		MOV sec,-(R6)
		MOV TOTAL_TIME_SEC_POSITION,-(R6)
		MOV #2,-(R6)
		JSR R7, uint2str
		ADD #6,R6

		rts		r7

csec2seccsec:; Uses R0, R1
		MOV	4(R6),R0	; R0 = csec
		MOV 2(R6),R1	; R1 = &[sec,csec]

		; sec, csec = div csec 100
		MOV R0,-(R6)
		MOV #100,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

sec2minsec:; Uses R0, R1
		MOV	4(R6),R0	; R0 = sec
		MOV 2(R6),R1	; R1 = &[min,sec]

		; min, sec = div sec 60 
		MOV R0,-(R6)
		MOV #60,-(R6)
		MOV R1,-(R6)
		JSR R7,div
		ADD #6,R6

		RTS	R7			; return;

div:; Uses R0, R1, R2
		MOV	6(R6),R0	; R0 = a
		MOV	4(R6),R1	; R1 = b
		MOV	2(R6),R2	; R2 = &[quociente,resto]
		MOV	#0,(R2)		; quociente = 0;

	div_loop:
		CMP	R0,R1		; while (a >= b) {
		BLT	div_end
		INC	(R2)		; 	++quociente;
		SUB	R1,R0		; 	a -= b;
		JMP	div_loop	; }

	div_end:
		MOV R0,2(R2)	; resto = a
		RTS	R7			; return;

uint2str_aux: daw [2]
uint2str:; uses R0, R1, R2, R3, R4
		MOV	6(R6),R0	; R0 = src -> uint
		MOV	4(R6),R1	; R1 = *dst -> byte array
		MOV	2(R6),R2	; R2 = dst_len -> uint

		MOV #uint2str_aux,R3
		MOV #0, R4
		
	uint2str_loop:
		CMP R2,R4
		BLE uint2str_end

		; uint2str_aux = div src 10
		MOV R1,-(R6)
		MOV R2,-(R6)
		MOV R3,-(R6)
		MOV R4,-(R6)

		MOV R0,-(R6)
		MOV #10,-(R6)
		MOV R3,-(R6)
		JSR R7,div
		ADD #6,R6

		MOV (R6)+,R1
		MOV (R6)+,R2
		MOV (R6)+,R3
		MOV (R6)+,R4

		; R0 = quociente
		MOV (R3), R0

		; R1 = resto + '0'
		MOV #'0',(R1)
		ADD 2(R3),(R1)

		INC R1
		INC R4
		JMP uint2str_loop
		
	uint2str_end:
		RTS	R7


;
;**************************************************************************************************
; Simula um processamento demorado
Wait:
		rts	R7
		mov		#10,r0
WaitLoopR0:
		mov		#30000,r1
WaitLoopR1:
		sob		r1,WaitLoopR1
		sob		r0,WaitLoopR0
		rts		r7
		
;
;**************************************************************************************************
; Limpa o visor
base_visor:		dab '000,00[0] 000,00[0] 000,00[0]  00:00'
ClearDisplay:
		MOV #36,-(R6)

		MOV #base_visor,-(R6)
		DEC (R6)	;MOV para algum endereco do visor ignora o MSB, entao comecamos antes

		MOV #VISOR,-(R6)
		JSR R7,memcpy
		ADD #6,R6
		RTS R7
		
memcpy:
		MOV	6(R6),R0	; R0 = len
		MOV 4(R6),R1	; R1 = &src_start
		MOV 2(R6),R2	; R2 = &src_dest

	memcpy_loop:
		TST R0
		BEQ memcpy_end	; while R0 != 0
		MOV (R1),(R2)
		INC R1
		INC R2
		DEC R0
		JMP memcpy_loop
	memcpy_end:
		RTS	R7
; ;
; ;**************************************************************************************************
; ; Rotinas para a manipulação do hardware e interrupção (se houver) do teclado
; ; TeclaDisponivel	-> Rotina que informa se algo foi digitado
; ; GetTecla			-> Rotina que retorna a tecla digitada

; ; <<2>> Configuração da leitura de teclado

; ;
; ; Rotina que informa se algo foi digitado
; ; Retorna R0==0, se nada digitado; R0!=0, se algo digitado
; TeclaDisponivel:	jmp		TeclaDisponivel_2

; ; Rotina que retorna a tecla digitada
; GetTecla:			jmp		GetTecla_2


; ; Versão 2 das funções
; TeclaDisponivel_2:
; 		and		#h7f,INTE			; IE = 0;
		
; 		clr		r0					; R0 = (prOut==ptIn ? FALSE:TRUE);
; 		cmp		ptOut, ptIn
; 		beq		TD_2_1
; 		mov		#1,r0
; TD_2_1:

; 		or		#h80,INTE			; IE = 1;
; 		rts		r7
		
; GetTecla_2:
; 		and		#h7f,INTE			; IE = 0
		
; 		mov		ptOut,r1			; r0 = *ptOut++
; 		dec		r1
; 		mov		TEC_BUFFER(r1),r0
; 		add		#2,r1
		
; 		and		#hff,r0				; r0 &= 0xFF
		
; 		and		#h1f,r1				; ptOut = ptOut & 0x1F // loop around pointer
; 		mov		r1,ptOut		
		
; 		or		#h80,INTE			; IE = 1
; 		rts		r7

				
;
;**************************************************************************************************
; Rotina de INTERRUPÇÃO
; Só será chamada se as interrupções estiverem habilitadas
ISR:
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)
isr1:
		mov		INTS,r0		; Verifica se é INT do TIMER
		and		#1,r0
		beq		isr2
		jsr		r7,isr_tim	; Tratamento da INT do TIMER
		and		#hFFFE,INTS	; Desliga bit de INT TIMER
isr2:
		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		isr3
		jsr		r7,isr_tec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO
isr3:

		mov		(r6)+,r5	; Retorna os registradores da pilha
		mov		(r6)+,r4
		mov		(r6)+,r3
		mov		(r6)+,r2
		mov		(r6)+,r1
		mov		(r6)+,r0

		rti					; Return From Interrupt


; Tratamento das interrupções de teclado
isr_tec:
		tst		TECST				; if (Tecla está disponivel?) {
		beq		isr_tec_end
		
		mov		ptIn,r2				; 		p = (in+1)&0x1F
		inc		r2
		and		#h1F,r2
		cmp		r2,ptOut			; 		if (p!=out) { // Verifica se o BUFFER ESTA CHEIO
		beq		isr_tec_2
		
		mov		ptIn,r1				;				*in = TECLA
		dec		r1
		mov		TEC_BUFFER(r1),r0
		and		#hFF00,r0
		or		TECDT,r0
		mov		r0,TEC_BUFFER(r1)
		
		mov		r2,ptIn				;				in = p
									; 		}

isr_tec_2:
		clr 	TECST				;
	
isr_tec_end:	
		rts	r7						; }
	

isr_tim:
		INC TICKCNT
		DEC TICKS_TIL_SEC
		BNE isr_tim_end
		INC sec_since_start

isr_tim_end:
		rts	r7
		
; VAR
TICKCNT:			dw	0
TICKS_TIL_SEC:		dw	0

sec_since_start: 	dw	125	; Segundos deste o início
cs_since_tec: 		daw [3] ; Centésimos de segundo desde a última volta, 1 para cada cronômetro
laps:				daw	[3]	; Quantidade de voltas, 1 para cada cronomêtro

; Par minuto:segundo para exibir na tela, computado a partir de sec_since_start
min:				dw 0
sec:				dw 0

; 3 Pares segundo:centésimo de segundo para exibir na tela, computado a partir de cs_since_tec
sec_csec:			daw [6]

ptIn:				dw	0
ptOut:				dw	0
TEC_BUFFER:			dab	[32]
